/////////////////////////////////////////////////////////////////////////////
// Name:        equpdatermainwin.cpp
// Purpose:     
// Author:      xj
// Modified by: 
// Created:     15/11/2010 09:26:40
// RCS-ID:      
// Copyright:   XJ-1
// Licence:     
/////////////////////////////////////////////////////////////////////////////

// Generated by DialogBlocks (unregistered), 15/11/2010 09:26:40

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"
#include "wx/file.h"
#include "wx/mstream.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
////@end includes

#include "equpdatermainwin.h"
#include "Resource.h"

////@begin XPM images
////@end XPM images

#define ELEMENT_LIST "List"
#define ELEMENT_GROUP "Group"
#define ELEMENT_ITEM "Item"
#define ATTRIBUTE_DIRECTORY "Directory"
#define ATTRIBUTE_TYPE "Type"
#define ATTRIBUTE_FILE "File"
#define ATTRIBUTE_CODE "Code"
#define ATTRIBUTE_PATH "Path"

#define wxELEMENT_LIST wxT(ELEMENT_LIST)
#define wxELEMENT_GROUP wxT(ELEMENT_GROUP)
#define wxELEMENT_ITEM wxT(ELEMENT_ITEM)
#define wxATTRIBUTE_DIRECTORY wxT(ATTRIBUTE_DIRECTORY)
#define wxATTRIBUTE_TYPE wxT(ATTRIBUTE_TYPE)
#define wxATTRIBUTE_FILE wxT(ATTRIBUTE_FILE)
#define wxATTRIBUTE_CODE wxT(ATTRIBUTE_CODE)
#define wxATTRIBUTE_PATH wxT(ATTRIBUTE_PATH)

#define GROUP_TYPE_DIR "GROUP_TYPE_DIR"
#define GROUP_TYPE_PACK "GROUP_TYPE_PACK"

#define wxGROUP_TYPE_DIR wxT(GROUP_TYPE_DIR)
#define wxGROUP_TYPE_PACK wxT(GROUP_TYPE_PACK)

#define TEMP_LOAD_DIR "../download/"
#define DESC_SUFFIX ".desc"

#define CONFIG_FILE "UpdateCfg.ini"
#define CONFIG_FILE2 "../Config/UpdateCfg.ini"
#define CONFIG_VARS "VARS"

#define EXISTS_TYPE_NONE 0
#define EXISTS_TYPE_TEMP 1
#define EXISTS_TYPE_DEST 2

#define BG_COLOR_KEY 53,46,44

#define LIST_FILE_HAS_LOAD_IN_USERDIR

extern void RunGame(wxChar *param, wxChar *user, wxChar *pwd);

/*
 * EQUpdaterMainWin type definition
 */

IMPLEMENT_CLASS( EQUpdaterMainWin, wxFrame )


/*
 * EQUpdaterMainWin event table definition
 */

BEGIN_EVENT_TABLE( EQUpdaterMainWin, wxFrame )

////@begin EQUpdaterMainWin event table entries
	EVT_CLOSE( EQUpdaterMainWin::OnCloseWindow )
	EVT_WINDOW_DESTROY( EQUpdaterMainWin::OnDestroy )
	EVT_TIMER(ID_TIMER_MAIN, EQUpdaterMainWin::OnTimer)
	EVT_MOUSE_EVENTS( EQUpdaterMainWin::OnMouse )
	EVT_ERASE_BACKGROUND( EQUpdaterMainWin::OnEraseBackground )
	EVT_PAINT( EQUpdaterMainWin::OnPaint )
	EVT_KEY_DOWN(EQUpdaterMainWin::OnKeyDown)
	EVT_KEY_UP(EQUpdaterMainWin::OnKeyUp)
////@end EQUpdaterMainWin event table entries

END_EVENT_TABLE()


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void CheckDeclaration(TiXmlDocument &xmlDoc)
{
	bool hasDecl = false;
	TiXmlNode *xmlDecl = xmlDoc.FirstChild();
	while(xmlDecl)
	{
		if(TiXmlNode::TINYXML_DECLARATION == xmlDecl->Type())
		{
			hasDecl = true;
			break;
		}

		xmlDecl = xmlDecl->NextSibling();
	}
	if(false == hasDecl)
	{
		TiXmlDeclaration xmlDecl("1.0", "", "");
		if(xmlDoc.NoChildren())
			xmlDoc.InsertEndChild(xmlDecl);
		else
			xmlDoc.InsertBeforeChild(xmlDoc.FirstChild(), xmlDecl);
	}
}

void CheckRootElement(TiXmlDocument &xmlDoc, const char *rootDir)
{
	TiXmlElement *eleList = xmlDoc.RootElement();
	if(NULL == eleList)
	{
		eleList = new TiXmlElement(ELEMENT_LIST);
		eleList->SetAttribute(ATTRIBUTE_DIRECTORY, rootDir);
		xmlDoc.LinkEndChild(eleList);
	}
}

void FormatXmlDoc( wxString &strXmlDoc )
{
	strXmlDoc.Replace(wxString::Format(wxT("<%s"), wxELEMENT_LIST), wxString::Format(wxT("\n<%s"), wxELEMENT_LIST));
	strXmlDoc.Replace(wxString::Format(wxT("<%s"), wxELEMENT_GROUP), wxString::Format(wxT("\n  <%s"), wxELEMENT_GROUP));
	strXmlDoc.Replace(wxString::Format(wxT("<%s"), wxELEMENT_ITEM), wxString::Format(wxT("\n    <%s"), wxELEMENT_ITEM));
	strXmlDoc.Replace(wxString::Format(wxT("</%s"), wxELEMENT_GROUP), wxString::Format(wxT("\n  </%s"), wxELEMENT_GROUP));
	strXmlDoc.Replace(wxString::Format(wxT("</%s"), wxELEMENT_LIST), wxString::Format(wxT("\n</%s"), wxELEMENT_LIST));

}

void PrintXmlDoc(TiXmlDocument &xmlDoc, wxString &strXmlDoc)
{
	TiXmlPrinter xmlPrint;

	xmlPrint.SetStreamPrinting();
	xmlDoc.Accept(&xmlPrint);

	strXmlDoc = XFuns::S2WS(std::string(xmlPrint.CStr())).c_str();
}

bool SaveXmlDocToFile(wxString &strXmlDoc, wxString &file)
{
	FILE *pf = fopen(file.char_str(), "w");

	wxWritableCharBuffer wbuf = strXmlDoc.char_str();
	size_t n = strlen(wbuf.data());
	fwrite(wbuf.data(), 1, n, pf);

	fflush(pf);
	fclose(pf);

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool LoadUserRes(UINT rid, const char *type, void **data, UINT *size)
{
	HRSRC hres = FindResourceA(NULL, MAKEINTRESOURCEA(rid), type);
	if(NULL == hres)
		return false;

	HGLOBAL hdat = LoadResource(NULL, hres);
	if(NULL == hdat)
		return false;

	LPVOID lpdat = LockResource(hdat);
	DWORD dsize = SizeofResource(NULL, hres);

	*data = malloc(dsize);
	memcpy(*data, lpdat, dsize);
	*size = dsize;

	GlobalUnlock(hdat);

	FreeResource(hdat);

	return true;
}

bool LoadImageFromUserRes(wxBitmap &bitmap, UINT rid, const char *type)
{
	void *rdata;
	UINT rsize;

	if(false == LoadUserRes(rid, type, &rdata, &rsize))
		return false;

	wxMemoryInputStream stream(rdata, rsize);
	wxImage img;
	img.LoadFile(stream);
	wxBitmap bmp(img);

	bitmap = bmp;

	free(rdata);

	return true;
}

/*
 * EQUpdaterMainWin constructors
 */

EQUpdaterMainWin::EQUpdaterMainWin()
{
    Init();
}

EQUpdaterMainWin::EQUpdaterMainWin( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
    Init();
    Create(parent, id, caption, pos, size, style);
}


/*
 * EQUpdaterMainWin creator
 */

bool EQUpdaterMainWin::Create( wxWindow* parent, wxWindowID id, const wxString& caption, const wxPoint& pos, const wxSize& size, long style )
{
    wxFrame::Create( parent, id, caption, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }

	LoadImageFromUserRes(m_bmpBg, IDB_PNG1, "PNG");
	LoadImageFromUserRes(m_bmpPb, IDB_PNG2, "PNG");
	LoadImageFromUserRes(m_bmpPh, IDB_PNG3, "PNG");
	LoadImageFromUserRes(m_bmpBtnN, IDB_PNG4, "PNG");
	LoadImageFromUserRes(m_bmpBtnH, IDB_PNG5, "PNG");
	LoadImageFromUserRes(m_bmpBtnP, IDB_PNG6, "PNG");

	m_bmpPb.SetMask(new wxMask(m_bmpPb, wxColour(BG_COLOR_KEY)));
	m_bmpPh.SetMask(new wxMask(m_bmpPh, wxColour(BG_COLOR_KEY)));

	SetSize(wxSize(m_bmpBg.GetWidth(), m_bmpBg.GetHeight()));

	//m_bmpRg = m_bmpBg;
	//SetWindowShape(m_bmpRg);

	m_pLBFile->SetBgBmp(&m_bmpBg);
	//m_pLBFile->SetLabel(wxT("当前进度"));
	m_pLBTotal->SetBgBmp(&m_bmpBg);
	//m_pLBTotal->SetLabel(wxT("总体进度"));
	m_pTimeFile->SetBgBmp(&m_bmpBg);
	m_pTimeFile->SetAlign(wxALIGN_RIGHT|wxALIGN_TOP);
	m_pTimeTotal->SetBgBmp(&m_bmpBg);
	m_pTimeTotal->SetAlign(wxALIGN_RIGHT|wxALIGN_TOP);
	m_pGaugeFile->SetBgBmp(&m_bmpPb);
	m_pGaugeFile->SetRgBmp(&m_bmpPh);
	m_pGaugeAll->SetBgBmp(&m_bmpPb);
	m_pGaugeAll->SetRgBmp(&m_bmpPh);
	m_pBtnClose->SetHoverBmp(&m_bmpBtnH);
	m_pBtnClose->SetNormalBmp(&m_bmpBtnN);
	m_pBtnClose->SetPushedBmp(&m_bmpBtnP);

	m_timer.SetOwner(this, ID_TIMER_MAIN);
	m_timer.Start(10);

	Centre();

    return true;
}

/*
* Control creation for EQUpdaterMainWin
*/

void EQUpdaterMainWin::CreateControls()
{    
	////@begin EQUpdaterMainWin content construction
	// Generated by DialogBlocks, 15/11/2010 14:31:17 (unregistered)

	EQUpdaterMainWin* itemDialog1 = this;

	/*wxHtmlWindow* itemHtmlWindow1 = new wxHtmlWindow( itemDialog1, ID_HTMLWINDOW, wxPoint(50, 147), wxSize(290, 188), wxHW_SCROLLBAR_AUTO|wxHSCROLL|wxVSCROLL );
	wxHtmlWindow* itemHtmlWindow2 = new wxHtmlWindow( itemDialog1, ID_HTMLWINDOW, wxPoint(347, 147), wxSize(144, 188), wxHW_SCROLLBAR_AUTO|wxHSCROLL|wxVSCROLL );

	m_pGaugeFile = new wxGaugeX( itemDialog1, ID_GAUGE, wxPoint(52, 360), wxSize(437, 13), 0 );
	m_pGaugeAll = new wxGaugeX( itemDialog1, ID_GAUGE1, wxPoint(52, 393), wxSize(437, 13), 0 );
	m_pLBFile = new wxStaticTextX(itemDialog1, wxID_ANY, wxPoint(52, 345), wxSize(300, 13), 0);
	m_pLBTotal = new wxStaticTextX(itemDialog1, wxID_ANY, wxPoint(52, 379), wxSize(100, 13), 0);
	m_pTimeFile = new wxStaticTextX( itemDialog1, wxID_ANY, wxPoint(352, 345), wxSize(137, 13), 0 );
	m_pTimeTotal = new wxStaticTextX( itemDialog1, wxID_ANY, wxPoint(352, 379), wxSize(137, 13), 0 );*/

	m_pGaugeFile = new wxGaugeX( itemDialog1, ID_GAUGE, wxDefaultPosition, wxSize(403, 13), 0 );
	m_pGaugeAll = new wxGaugeX( itemDialog1, ID_GAUGE1, wxPoint(6, 242), wxSize(437, 13), 0 );
	m_pLBFile = new wxStaticTextX(itemDialog1, wxID_ANY, wxPoint(6, 242-13), wxSize(300, 13), 0);
	m_pLBTotal = new wxStaticTextX(itemDialog1, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0);
	m_pTimeFile = new wxStaticTextX( itemDialog1, wxID_ANY, wxDefaultPosition, wxDefaultSize, 0 );
	m_pTimeTotal = new wxStaticTextX( itemDialog1, wxID_ANY, wxPoint(384, 242-13), wxSize(60, 13), 0 );
	m_pBtnClose = new wxButtonX( itemDialog1, ID_BUTTON_CLOSE, wxPoint(429, 3), wxSize(18, 18), 0 );

	m_pBtnClose->Connect(ID_BUTTON_CLOSE, wxEVT_LEFT_UP, wxMouseEventHandler(EQUpdaterMainWin::OnBtnCloseLeftUp), NULL, this);

	m_pLBFile->SetLabel(wxT("数据读取中......"));

	m_pGaugeFile->Hide();
	m_pLBFile->Hide();
	m_pLBTotal->Hide();
	m_pTimeFile->Hide();
	m_pTimeTotal->Hide();

	////@end EQUpdaterMainWin content construction
}

/*
 * EQUpdaterMainWin destructor
 */

EQUpdaterMainWin::~EQUpdaterMainWin()
{

}

/*
 * Member initialisation
 */

void EQUpdaterMainWin::Init()
{
	m_terminate = false;
	m_loading = false;
	m_abort = false;
	m_loadState = 0;
	m_loadedCnt = 0;
	m_totalLoadCnt = 0;
	m_totalMoveCnt = 0;
	m_loadedSize = 0;
	m_curTotal = 0;
	m_curDown = 0;

	m_totalUseTimeT = 0;

	m_loadUrlObj = 0;
	m_loadThreadObj = 0;
	m_loadHFile = 0;

	m_runAfter = false;
	m_hasUpdateMe = false;
	m_mouseHasDown = false;
	m_allSuccess = true;

	m_curHDesc = NULL;
	m_curListDoc = NULL;

	m_para = NULL;
	m_user = NULL;
	m_pwd = NULL;

	curl_global_init(CURL_GLOBAL_WIN32);

	LoadConfig();

}

void EQUpdaterMainWin::Dispose()
{
	if(m_timer.IsRunning())
		m_timer.Stop();

	m_terminate = true;

	if(m_loadUrlObj)
	{
		curl_easy_pause( m_loadUrlObj, CURLPAUSE_ALL );
		curl_easy_cleanup( m_loadUrlObj );
		m_loadUrlObj = NULL;
	}

	if(m_loadThreadObj)
	{
		m_loadThreadObj->Kill();
		m_loadThreadObj = NULL;
	}

	if(m_loadHFile)
	{
		fclose(m_loadHFile);
		m_loadHFile = NULL;
	}

	if(m_curHDesc)
	{
		fclose(m_curHDesc);
		m_curHDesc = NULL;
	}

	CloseListFile();

	ClearFileList(m_updateList);

	for(LOADFILEITEMLIST::iterator itr = m_loadFiles.begin(); itr != m_loadFiles.end(); ++itr)
		delete *itr;
	m_loadFiles.clear();

	curl_global_cleanup();

}

/*
 * Should we show tooltips?
 */

bool EQUpdaterMainWin::ShowToolTips()
{
    return true;
}

void DrawMoveRect(int x1, int y1, int x2, int y2)
{
	HDC hDC = GetDC(NULL);

	int oldrop2 = SetROP2(hDC, R2_XORPEN);
	HBRUSH oldHBrush = (HBRUSH)SelectObject(hDC, GetStockObject(NULL_BRUSH));
	HPEN newHPen = CreatePen(PS_DOT, 2, RGB(0x90, 0x90, 0x90));
	HPEN oldHPen = (HPEN)SelectObject(hDC, newHPen);

	Rectangle(hDC, x1, y1, x2, y2);

	SetROP2(hDC, oldrop2);
	SelectObject(hDC, oldHBrush);
	SelectObject(hDC, oldHPen);

	DeleteObject(newHPen);

	ReleaseDC(NULL, hDC);
}

void EQUpdaterMainWin::OnMouse( wxMouseEvent& event )
{
	if(event.ButtonDown(wxMOUSE_BTN_LEFT))
	{
		CaptureMouse();
		m_ptDown = event.GetPosition();
		m_ptOld = this->GetPosition();

		wxSize size = this->GetSize();
		DrawMoveRect(m_ptOld.x, m_ptOld.y, m_ptOld.x + size.x, m_ptOld.y + size.y);

		m_mouseHasDown = true;
	}
	else if(event.ButtonUp(wxMOUSE_BTN_LEFT))
	{
		if(m_mouseHasDown)
		{
			wxSize size = this->GetSize();
			DrawMoveRect(m_ptOld.x, m_ptOld.y, m_ptOld.x + size.x, m_ptOld.y + size.y);

			this->Move(m_ptOld);

			m_mouseHasDown = false;

			if(HasCapture())
				ReleaseMouse();
		}
	}
	else if(event.Dragging())
	{
		if(m_mouseHasDown)
		{
			wxPoint curPt = this->GetPosition();
			wxPoint curMPt = event.GetPosition();
			wxSize size = this->GetSize();

			DrawMoveRect(m_ptOld.x, m_ptOld.y, m_ptOld.x + size.x, m_ptOld.y + size.y);

			curPt.x += (curMPt.x - m_ptDown.x);
			curPt.y += (curMPt.y - m_ptDown.y);

			DrawMoveRect(curPt.x, curPt.y, curPt.x + size.x, curPt.y + size.y);

			m_ptOld.x = curPt.x;
			m_ptOld.y = curPt.y;
		}
	}

	event.Skip();
}

void EQUpdaterMainWin::OnEraseBackground( wxEraseEvent& event )
{
	wxClientDC *cdc = NULL;

	if(NULL == event.GetDC())
		cdc = new wxClientDC(this);

	wxClientDC *dc = cdc ? cdc : static_cast<wxClientDC*>(event.GetDC());

	//dc->DrawBitmap(m_bmpBg, 0, 0, true);
	dc->DrawBitmap(m_bmpBg, 0, 0);

	if(cdc)
		delete cdc;
}

void EQUpdaterMainWin::OnPaint( wxPaintEvent& event )
{

	event.Skip();
}

void EQUpdaterMainWin::OnKeyDown(wxKeyEvent& event)
{

}

void EQUpdaterMainWin::OnKeyUp( wxKeyEvent& event )
{
	if(WXK_ESCAPE != event.GetKeyCode())
		return;

	if(wxNO == wxMessageBox(wxT("游戏正在更新中，确定要退出吗？"), wxT("退出确认"), wxICON_QUESTION|wxYES|wxNO, this))
		return;

	Close();

}

void EQUpdaterMainWin::OnBtnCloseLeftUp( wxMouseEvent& event )
{
	if(wxYES == wxMessageBox(wxT("游戏正在更新中，确定要退出吗？"), wxT("退出确认"), wxICON_QUESTION|wxYES|wxNO, this))
		Close();

	event.Skip();

}

//void EQUpdaterMainWin::SetWindowShape(wxBitmap &bmpShape)
//{
//	wxColour ck(BG_COLOR_KEY);
//	wxRegion region(bmpShape, ck);
//
//	SetShape(region);
//}

/*
 * Get bitmap resources
 */

wxBitmap EQUpdaterMainWin::GetBitmapResource( const wxString& name )
{
    // Bitmap retrieval
////@begin EQUpdaterMainWin bitmap retrieval
    wxUnusedVar(name);
    return wxNullBitmap;
////@end EQUpdaterMainWin bitmap retrieval
}

/*
 * Get icon resources
 */

wxIcon EQUpdaterMainWin::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin EQUpdaterMainWin icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end EQUpdaterMainWin icon retrieval
}

void EQUpdaterMainWin::StartGame()
{
	//自己有升级
	if(m_hasUpdateMe)
	{
		wxString vars = wxT("");
		if(m_para)
			vars = wxString::Format(wxT("%s %s %s"), m_para, m_user, m_pwd);

		static char curDir[MAX_PATH + 1];
		GetCurrentDirectoryA(MAX_PATH, curDir);

		std::string runExe = "";
		runExe.append(curDir);
		runExe.append("\\EQUpdaterI.exe");

		if(!XFuns::RunExe(runExe.c_str(), curDir, vars.char_str().data()))
		{
			wxMessageBox(wxT("无法启动更新程序！"), wxT("错误"), wxICON_ERROR|wxOK|wxCENTER);
		}
	}
	else
	{
		RunGame(m_para, m_user, m_pwd);
	}

	Close();

}

void EQUpdaterMainWin::OnTimer( wxTimerEvent &event )
{
	//更新显示剩余时间
	//DWORD speed, leaveMillisecond, leaveTotalSecond, leaveMinute = 0, leaveSecond = 0, leaveMinuteT = 0, leaveSecondT = 0;
	DWORD timeSpan = GetTickCount() - m_stime;
	//更新下载状态
	if(timeSpan > 249)
	{
	//	m_totalUseTime += timeSpan;
	//	if(m_totalUseTime && m_curDown)
	//	{
	//		speed = m_curDown / m_totalUseTime;
	//		if(speed)
	//		{
	//			leaveMillisecond = ((m_curTotal - m_curDown) / speed);
	//			leaveTotalSecond = leaveMillisecond / 1000;
	//			leaveMinute = leaveTotalSecond / 60;
	//			leaveSecond = leaveTotalSecond % 60;
	//		}
	//	}

	//	m_totalUseTimeT += timeSpan;
	//	if(m_totalUseTimeT && m_loadedCnt)
	//	{
	//		speed = m_totalUseTimeT / m_loadedCnt;

	//		leaveMillisecond = speed * (m_totalLoadCnt - m_loadedCnt);
	//		leaveTotalSecond = leaveMillisecond / 1000;
	//		leaveMinuteT = leaveTotalSecond / 60;
	//		leaveSecondT = leaveTotalSecond % 60;
	//	}

	//	m_pTimeFile->SetLabel(wxString::Format(wxT("%d分%d秒"), leaveMinute, leaveSecond));
	//	m_pTimeTotal->SetLabel(wxString::Format(wxT("%d分%d秒"), leaveMinuteT, leaveSecondT));

		//////////////////////////////////////////////////////////////////////////////////////////
		int c = m_pGaugeFile->GetValue(), t = m_pGaugeFile->GetRange(), p = 0;
		if(c && t)
			p = c * 100 / t;
		m_pTimeTotal->SetLabel(wxString::Format(wxT("%d%%"), p));
		//////////////////////////////////////////////////////////////////////////////////////////

		m_stime = GetTickCount();
	}

	if(m_loading)
		return;

	if(m_abort)
	{
		m_timer.Stop();
		Close();
		return;
	}

	if(0 == m_loadedCnt)
	{
		LoadList();
	}
	else
	{
		if(0 == m_loadFiles.size())
		{
			m_timer.Stop();

			//m_pLBFile->SetLabel(wxT("正在移动合并"));
			//将下载的文件从临时目录移到目标目录或包里
			MoveToTarget();
			//关闭更新列表
			CloseListFile();
			//若所有文件都更新成功则替换现有列表文件，加快下次启动时比较速度。
			/*if(m_allSuccess)
			{
				if(0 == remove(m_listFile.c_str()))
					rename(m_tmpListFile.c_str(), m_listFile.c_str());
			}*/
			//删除临时目录剩下的文件
			XFuns::DelDir(TEMP_LOAD_DIR, false);
			//启动游戏
			StartGame();
		}
		else
		{
			StartLoad(m_loadFiles.front());
		}

	}

}

void EQUpdaterMainWin::OnCloseWindow( wxCloseEvent& event )
{
	Dispose();

	event.Skip();

}

void EQUpdaterMainWin::OnDestroy( wxWindowDestroyEvent& event )
{

	event.Skip();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////下载回调/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
size_t CURLDownLoadCallBack( void *buffer, size_t size, size_t nmemb, void *userp )
{

	return fwrite(buffer, size, nmemb, (FILE *)userp);
}

int CURLProgressCallBack(void *clientp, double dltotal, double dlnow, double ultotal, double ulnow)
{
	EQUpdaterMainWin *upm = (EQUpdaterMainWin *)clientp;

	upm->UpdateLoadStatus((int)dltotal, (int)dlnow);

	return 0;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//开始文件下载
void EQUpdaterMainWin::StartLoad( LPLOADFILEITEM dlInfo )
{
	m_loadThreadObj = new WxThreadCls(this, dlInfo);

	if(NULL == m_loadThreadObj)
		return;

	if(wxTHREAD_NO_ERROR != m_loadThreadObj->Create())
		return;

	if(wxTHREAD_NO_ERROR != m_loadThreadObj->Run())
		return;

	m_loading = true;

}

//结束文件下载时触发
void EQUpdaterMainWin::EndLoad( LPLOADFILEITEM dlInfo )
{
	if(0 == m_loadedCnt)
	{
		if(false == dlInfo->IsError)
		{
			//m_pLBFile->SetLabel(wxT("正在生成下载列表"));

			DWORD st = GetTickCount();

			OpenListFile();
			BuildLoadList2();

			XLog::Write("Build load list ok, use time:%d. Load:%d,Move:%d", GetTickCount() - st, m_totalLoadCnt, m_totalMoveCnt);
		}
	}
	else
	{
		if(dlInfo->IsError)
		{
			SetErrorFile(dlInfo->Path);
			m_allSuccess = false;
		}
		else
			XLog::Write("Load file%d [%s] ok!", m_loadedCnt, dlInfo->ItemFile.c_str());

		m_loadFiles.pop_front();
	}

	m_pGaugeAll->SetValue(m_loadedCnt);
	////////////////////////////////////////////////////////////////////////////////////////////////
	//int cur = m_pGaugeAll->GetValue(), total = m_pGaugeAll->GetRange(), per = 0;
	//if(cur && total)
	//	per = cur * 100 / total;

	//m_pTimeTotal->SetLabel(wxString::Format(wxT("%d%%"), per));
	////////////////////////////////////////////////////////////////////////////////////////////////

	delete dlInfo;

	m_loadedCnt ++;

	m_loading = false;

}

//下载列表文件
void EQUpdaterMainWin::LoadList()
{
	LPLOADFILEITEM dlInfo = new LOADFILEITEM;

#ifndef LIST_FILE_HAS_LOAD_IN_USERDIR
	dlInfo->Url.append(m_serverAddr);
	dlInfo->Url.append(m_listFName);
#endif
	dlInfo->Path.append(m_tmpListFile);
	dlInfo->IsExit = false;
	dlInfo->IsError = false;
	dlInfo->Size = 0;
	dlInfo->StartPos = 0;

	StartLoad(dlInfo);

}

//下载一个文件
void EQUpdaterMainWin::LoadFile( LPLOADFILEITEM dlInfo )
{
	CURLcode rtn;
	char fv[128];
	int total;

	//要下载的为空
	if(dlInfo->Url.empty())
		return;

	std::string fpath = dlInfo->Path;

	m_curHDesc = NULL;
	m_loadedSize = 0;

	wxString lfile(XFuns::S2WS(fpath));
	int p = lfile.Last(wxT('/'));
	if(-1 != p)
		lfile.Remove(0, p + 1);
	//m_pLBFile->SetLabel(wxT("正在下载[") + lfile + wxT("]"));

	m_loadUrlObj = curl_easy_init();

	if (NULL == m_loadUrlObj)
	{
		dlInfo->IsError = true;
		XLog::Write("Error 'curl_easy_init'.");
		return;
	}

	std::string furl = dlInfo->Url;
	std::string dfpath = fpath + DESC_SUFFIX;

	fv[0] = 0;

	if(dlInfo->IsExit)
	{
		m_loadHFile = OpenFile(fpath.c_str(), "a+b");
		m_loadedSize = _filelength(fileno(m_loadHFile));

		FILE *pf = OpenFile(dfpath.c_str(), "rb");
		TEMPFILEDESC desc = {0};
		fread(&desc, sizeof(TEMPFILEDESC), 1, pf);
		fclose(pf);
		total = desc.Size;

		sprintf(fv, "%d-%d", m_loadedSize, total);

		fseek(m_loadHFile, 0, SEEK_END);
	}
	else
	{
		m_loadHFile = OpenFile(fpath.c_str(), "wb");

		m_curHDesc = OpenFile(dfpath.c_str(), "wb");

		ZeroMemory(&m_curDesc, sizeof(TEMPFILEDESC));
		strcpy(m_curDesc.Code, dlInfo->ItemCode.c_str());
	}

	if(NULL == m_loadHFile)
	{
		if(m_curHDesc)
		{
			fclose(m_curHDesc);
			m_curHDesc = NULL;
		}

		dlInfo->IsError = true;
		XLog::Write("Error open file [%s].", fpath.c_str());
		return;
	}

	m_loadState = 0;
	m_curTotal = 0;
	m_curDown = 0;

	curl_easy_setopt( m_loadUrlObj, CURLOPT_URL, furl.c_str() ); 
	curl_easy_setopt( m_loadUrlObj, CURLOPT_WRITEDATA, (void *)m_loadHFile ); 
	curl_easy_setopt( m_loadUrlObj, CURLOPT_WRITEFUNCTION, CURLDownLoadCallBack );//设置保存下载数据回调函数
	curl_easy_setopt( m_loadUrlObj, CURLOPT_NOPROGRESS, 0);
	curl_easy_setopt( m_loadUrlObj, CURLOPT_PROGRESSFUNCTION, CURLProgressCallBack );//设置进度获取回调函数
	curl_easy_setopt( m_loadUrlObj, CURLOPT_PROGRESSDATA, this);
	curl_easy_setopt( m_loadUrlObj, CURLOPT_CONNECTTIMEOUT, 20L);//设置20秒连接超时
	curl_easy_setopt( m_loadUrlObj, CURLOPT_TIMEOUT, 20L);//设置20秒下载超时
	curl_easy_setopt( m_loadUrlObj, CURLOPT_FORBID_REUSE, 1);//关闭重用连接机制，防止大量CLOSE_WAIT的TCP连接

	if(0 != fv[0])
		curl_easy_setopt( m_loadUrlObj, CURLOPT_RANGE, fv);

	rtn = curl_easy_perform( m_loadUrlObj );//下载

	//检测是否完成下载，若是中途失败，需继续尝试下载剩余部分。
	while(false == m_terminate)
	{
		if(CURLE_OK == rtn)
			break;

		XLog::Write("Load file [%s] error:%d", lfile.char_str(), rtn);

		bool tryAgain = true;
		wxString errMsg;

		switch(rtn)
		{
		case CURLE_RECV_ERROR:
			errMsg.Append(wxT("下载文件时发生错误"));
			break;
		case CURLE_COULDNT_CONNECT:
			errMsg.Append(wxT("网络暂时无法连接"));
			break;
		case CURLE_OPERATION_TIMEDOUT:
			errMsg.Append(wxT("下载文件连接超时"));
			break;
		default:
			tryAgain = false;
			break;
		}

		if(tryAgain)
		{
			errMsg.Append(wxT("，是否重试？"));
			if(wxNO == wxMessageBox(errMsg, wxString::Format(wxT("错误 %d"), rtn), wxICON_ERROR|wxYES|wxNO|wxCENTER, this))
			{
				m_abort = true;
				tryAgain = false;
				dlInfo->IsError = true;
			}
		}

		if(false == tryAgain)
			break;

		wxThread::Sleep(3000);

		total = m_pGaugeFile->GetRange();
		m_loadedSize = m_pGaugeFile->GetValue();

		sprintf(fv, "%d-%d", m_loadedSize, total);
		curl_easy_setopt( m_loadUrlObj, CURLOPT_RANGE, fv);

		rtn = curl_easy_perform( m_loadUrlObj );
	}

	if(false == m_abort)
	{
		//判断获取响应的http地址是否存在,若存在则返回200,206为只下部分,400以上则为不存在,一般不存在为404错误   
		int retcode = 0;   
		CURLcode rtng = curl_easy_getinfo(m_loadUrlObj, CURLINFO_RESPONSE_CODE , &retcode);     
		if(CURLE_OK != rtn || !(CURLE_OK == rtng && (200 == retcode || 206 == retcode)))   
		{
			dlInfo->IsError = true;

			wxWritableCharBuffer elf = lfile.char_str();
			XLog::Write("Error[%d,%d,%d]: load [%s].", rtn, rtng, retcode, elf.data());

			if(wxNO == wxMessageBox(wxString::Format(wxT("下载文件[%s]出错，请检查网络状况。是否继续下载剩余文件？"), lfile), 
				wxString::Format(wxT("错误 %d"), retcode), 
				wxICON_ERROR|wxYES|wxNO|wxCENTER,
				this))
			{
				m_abort = true;
			}
		}
	}

	curl_easy_cleanup( m_loadUrlObj );
	m_loadUrlObj = NULL;

	fclose(m_loadHFile);
	m_loadHFile = NULL;

	if(m_curHDesc)
	{
		m_curDesc.Size = m_curTotal;
		fwrite(&m_curDesc, sizeof(TEMPFILEDESC), 1, m_curHDesc);
		fclose(m_curHDesc);
		m_curHDesc = NULL;
	}
}

//下载线程函数
void EQUpdaterMainWin::ThreadPro( void *pv )
{
	LPLOADFILEITEM plf = (LPLOADFILEITEM)pv;

	//下载文件
	LoadFile(plf);

	//结束下载
	EndLoad(plf);

	//
	m_loadThreadObj = NULL;
}

//更新下载状态
void EQUpdaterMainWin::UpdateLoadStatus( int total, int down )
{
	if(0 == total && 0 == down)
		return;

	switch(m_loadState)
	{
	case 0://获取总大小和进行一些必要的准备
		m_pGaugeFile->SetRange(total + m_loadedSize);
		m_pGaugeFile->SetValue(m_loadedSize);
		m_loadState ++;
		m_totalUseTime = 0;
		m_curTotal = total;
		break;
	case 1://更新当前下载状
		m_pGaugeFile->SetValue(down + m_loadedSize);
		m_curDown = down;
		//单个文件下载完成
		if(total == down)
			m_loadState ++;
		break;
	}

}

void EQUpdaterMainWin::CheckIsMe( std::string &file )
{
	if(m_hasUpdateMe)
		return;

	int np = file.find("EQUpdaterI.exe");
	int np1 = file.find(CONFIG_FILE);

	if(-1 != np || -1 != np1)
		m_hasUpdateMe = true;

}

void EQUpdaterMainWin::CheckIsMe(const char *file)
{
	std::string ffile = file;

	CheckIsMe(ffile);

}

//从列表xml字符串文档中获取下载列表
void EQUpdaterMainWin::GetLoadFileItems( std::string &listFile, LOADFILELISTINFO &loadList, bool toMap )
{
	TiXmlDocument xmlDoc;

	if(false == xmlDoc.LoadFile(listFile.c_str()))
		return;

	TiXmlElement *eleList = xmlDoc.RootElement();
	if(NULL == eleList)
		return;

	const char *rootDir = eleList->Attribute(ATTRIBUTE_DIRECTORY);
	if(NULL == rootDir)
		return;

	loadList.Dir.reserve(32);
	loadList.Dir.append(rootDir);

	TiXmlElement *eleGroup = eleList->FirstChildElement();
	while(eleGroup)
	{
		const char *groupDir = eleGroup->Attribute(ATTRIBUTE_DIRECTORY);
		const char *groupType = eleGroup->Attribute(ATTRIBUTE_TYPE);

		if(NULL == groupDir || NULL == groupType)
			return;

		LOADFILEGROUPINFO groupInfo;
		groupInfo.Dir.reserve(64);
		groupInfo.sType.reserve(32);

		groupInfo.Dir.append(groupDir);
		groupInfo.sType.append(groupType);

		if(0 == strcmp(GROUP_TYPE_DIR, groupType))
			groupInfo.nType = nGROUP_TYPE_DIR;
		else if(0 == strcmp(GROUP_TYPE_PACK, groupType))
			groupInfo.nType = nGROUP_TYPE_PACK;

		std::string dstDir;

		dstDir.reserve(128);
		dstDir.append(m_targetDir);//目标存储根目录
		dstDir.append(rootDir);//列表文件中的根目录

		if(nGROUP_TYPE_DIR == groupInfo.nType)//目录类型组中的目录
			dstDir.append(groupDir);

		TiXmlElement *eleItem = eleGroup->FirstChildElement();
		while(eleItem)
		{
			const char *itemFile = eleItem->Attribute(ATTRIBUTE_FILE);
			const char *itemCode = eleItem->Attribute(ATTRIBUTE_CODE);

			if(NULL == itemFile || NULL == itemCode)
				return;

			LOADFILEINFO fileInfo;
			fileInfo.Code.reserve(33);
			fileInfo.DstPath.reserve(128);
			fileInfo.File.reserve(128);
			fileInfo.Path.reserve(128);
			fileInfo.Url.reserve(128);

			fileInfo.Url.append(m_serverAddr);
			fileInfo.Url.append(rootDir);
			fileInfo.Path.append(TEMP_LOAD_DIR);
			fileInfo.Path.append(rootDir);
			fileInfo.DstPath.append(dstDir);

			if(nGROUP_TYPE_DIR == groupInfo.nType)
			{
				fileInfo.Url.append(groupDir);
				fileInfo.Path.append(groupDir);
			}

			fileInfo.Url.append(itemFile);
			fileInfo.Path.append(itemFile);
			fileInfo.Code.append(itemCode);
			fileInfo.File.append(itemFile);
			fileInfo.DstPath.append(itemFile);

			if(toMap)
				groupInfo.FMaps.insert(std::make_pair(fileInfo.Url, fileInfo));
			else
				groupInfo.Files.push_back(fileInfo);

			eleItem = eleItem->NextSiblingElement();
		}

		loadList.Groups.push_back(groupInfo);

		eleGroup = eleGroup->NextSiblingElement();
	}
}

//生成下载列表
void EQUpdaterMainWin::BuildLoadList1()
{
	std::string tmpListFile = m_tmpListFile;

	//首先判断两个列表文件是否相同
	//if(false == Check2FileMd5(m_listFile.c_str(), tmpListFile.c_str()))
	{
		TiXmlDocument xmlDocTmp, xmlDocCur;
		TiXmlElement *lastGroup = NULL, *lastItem = NULL, *listRoot = NULL;
		std::string dstFile, tmpFile, fileUrl, dstDir;

		if(xmlDocCur.LoadFile(m_listFile.c_str()))
		{
			listRoot = xmlDocCur.RootElement();
			if(listRoot)
			{
				lastGroup = listRoot->FirstChildElement();
				if(lastGroup)
					lastItem = lastGroup->FirstChildElement();
			}
		}

		if(xmlDocTmp.LoadFile(tmpListFile.c_str()))
		{
			TiXmlElement *eleList = xmlDocTmp.RootElement();
			if(eleList)
			{
				char *rootDir = (char *)eleList->Attribute(ATTRIBUTE_DIRECTORY);

				if(NULL == rootDir)
					rootDir = "";

				dstFile.reserve(256);
				tmpFile.reserve(256);
				fileUrl.reserve(256);
				dstDir.reserve(256);

				m_updateList.Dir = rootDir;

				TiXmlElement *eleGroup = eleList->FirstChildElement();
				while(eleGroup)
				{
					char *groupDir = (char *)eleGroup->Attribute(ATTRIBUTE_DIRECTORY);
					char *groupType = (char *)eleGroup->Attribute(ATTRIBUTE_TYPE);
					BYTE nType = nGROUP_TYPE_DIR;

					if(NULL == groupDir)
						groupDir = "";
					if(NULL == groupType)
						groupType = "";

					if(0 == strcmp(GROUP_TYPE_DIR, groupType))
						nType = nGROUP_TYPE_DIR;
					else if(0 == strcmp(GROUP_TYPE_PACK, groupType))
						nType = nGROUP_TYPE_PACK;

					LOADFILEGROUPINFO ginfo;
					ginfo.Dir = groupDir;
					ginfo.nType = nType;
					ginfo.sType = groupType;

					dstDir.clear();
					dstDir.append(m_targetDir);//目标存储根目录
					dstDir.append(rootDir);//列表文件中的根目录

					if(nGROUP_TYPE_DIR == nType)//目录类型组中的目录
						dstDir.append(groupDir);

					TiXmlElement *eleItem = eleGroup->FirstChildElement();
					while(eleItem)
					{
						const char *itemFile = eleItem->Attribute(ATTRIBUTE_FILE);
						const char *itemCode = eleItem->Attribute(ATTRIBUTE_CODE);

						fileUrl.clear();
						dstFile.clear();
						tmpFile.clear();

						fileUrl.append(m_serverAddr);
						fileUrl.append(rootDir);
						tmpFile.append(TEMP_LOAD_DIR);
						tmpFile.append(rootDir);
						dstFile.append(dstDir);

						if(nGROUP_TYPE_DIR == nType)
						{
							fileUrl.append(groupDir);
							tmpFile.append(groupDir);
						}

						fileUrl.append(itemFile);
						tmpFile.append(itemFile);
						dstFile.append(itemFile);

						int nwhere = EXISTS_TYPE_NONE;
						DWORD startPos = 0;
						DWORD size = 0;

						if(IsChanged1(listRoot, &lastGroup, &lastItem, groupDir, itemFile, itemCode, dstFile.c_str(), tmpFile.c_str(), nwhere, startPos, size))
						{
							//加入下载列表
							if(EXISTS_TYPE_NONE == nwhere || (startPos != size))
							{
								LPLOADFILEITEM iinfo = new LOADFILEITEM;
								iinfo->Url = fileUrl;
								iinfo->Path = tmpFile;
								iinfo->GroupDir = groupDir;
								iinfo->GroupType = groupType;
								iinfo->ItemFile = itemFile;
								iinfo->ItemCode = itemCode;
								iinfo->IsExit = EXISTS_TYPE_NONE == nwhere ? false : true;
								iinfo->StartPos = startPos;
								iinfo->Size = size;
								iinfo->IsError = false;
								m_loadFiles.push_back(iinfo);
							}

							//加入移动列表
							if(EXISTS_TYPE_DEST != nwhere)
							{
								LOADFILEINFO finfo;
								finfo.Url = fileUrl;
								finfo.Path = tmpFile;
								finfo.Code = itemCode;
								finfo.DstPath = dstFile;
								finfo.File = itemFile;
								finfo.IsError = false;

								ginfo.Files.push_back(finfo);

								CheckIsMe(itemFile);

								m_totalMoveCnt ++;
							}

							//文件已在，但列表中没有，直接更新列表
							if(EXISTS_TYPE_DEST == nwhere)
								UpdateListFile(groupDir, groupType, itemFile, itemCode);
						}

						eleItem = eleItem->NextSiblingElement();
					}

					if(ginfo.Files.size())
						m_updateList.Groups.push_back(ginfo);

					eleGroup = eleGroup->NextSiblingElement();
				}
			}
		}
	}

	m_totalLoadCnt = m_loadFiles.size();
	m_stime = GetTickCount();
	m_totalUseTime = 0;
	m_totalUseTimeT = 0;

	m_pGaugeAll->SetRange(m_totalLoadCnt);
	m_pGaugeAll->SetValue(0);

}

bool EQUpdaterMainWin::IsChanged1(TiXmlElement *listRoot, TiXmlElement **lastGroup, TiXmlElement **lastItem, const char *groupDir, const char *itemFile, const char *code, const char *dstFile, const char *tmpFile, int &nWhere, DWORD &startPos, DWORD &size)
{
	TiXmlElement *curGroup = *lastGroup, *curItem = *lastItem;

	bool hasFind = false, isEqual = false, isBreak = false;

	while(1)
	{
		while(curGroup)
		{
			const char *gDir = curGroup->Attribute(ATTRIBUTE_DIRECTORY);

			if(0 == strcmp(gDir, groupDir))
			{
				while(curItem)
				{
					const char *iFile = curItem->Attribute(ATTRIBUTE_FILE);

					if(0 == strcmp(iFile, itemFile))
					{
						if(0 == strcmp(curItem->Attribute(ATTRIBUTE_CODE), code))
							isEqual = true;

						hasFind = true;
						isBreak = true;
					}

					curItem = curItem->NextSiblingElement();

					if(isBreak)
						break;

					if(curGroup == *lastGroup && curItem == *lastItem)
					{
						isBreak = true;
						break;
					}
				}
			}

			if(isBreak)
				break;

			curGroup = curGroup->NextSiblingElement();
			if(curGroup)
				curItem = curGroup->FirstChildElement();
		}

		if(isBreak)
			break;

		if(listRoot)
		{
			curGroup = listRoot->FirstChildElement();
			if(curGroup)
				curItem = curGroup->FirstChildElement();
		}

		if(curGroup == *lastGroup && curItem == *lastItem)
			break;
	}

	*lastGroup = curGroup;
	*lastItem = curItem;

	TEMPFILEDESC desc;

	//存在在用户列表中
	if(hasFind)
	{
		//Code相同并且在目标目录中
		if(isEqual && XFuns::CheckFileExists(dstFile))
			return false;

		//检查文件是否在临时目录中
		if(false == GetFileDesc(tmpFile, &desc))
			return true;
		//检查临时目录中的文件Code
		if(0 != strcmp(desc.Code, code))
			return true;

		startPos = XFuns::GetFileSize(tmpFile);
		size = desc.Size;
		nWhere = EXISTS_TYPE_TEMP;

		return true;
	}

	//用户列表中不存在，直接检查目标目录中文件的存在性和Code
	if(XFuns::CheckFileExists(dstFile))
	{
		if(false == XFuns::CheckFileMd5(dstFile, code))
			return true;

		startPos = XFuns::GetFileSize(dstFile);
		size = startPos;
		nWhere = EXISTS_TYPE_DEST;

		return true;
	}

	//用户列表中不存在，文件也不存在在目标目录中，检查在临时目录中是否存在
	if(false == XFuns::CheckFileExists(tmpFile))
		return true;

	if(false == GetFileDesc(tmpFile, &desc))
		return true;

	if(0 != strcmp(desc.Code, code))
		return true;

	startPos = XFuns::GetFileSize(tmpFile);
	size = desc.Size;
	nWhere = EXISTS_TYPE_TEMP;

	return true;

}

void EQUpdaterMainWin::BuildLoadList2()
{
	std::string tmpListFile = m_tmpListFile;

	//首先判断两个列表文件是否相同
	//if(false == Check2FileMd5(m_listFile.c_str(), tmpListFile.c_str()))
	{
		LOADFILELISTINFO loadList, tmpLoadList;

		DWORD st = GetTickCount();

		GetLoadFileItems(m_listFile, loadList, true);

		XLog::Trace("Use time1:%d\n", GetTickCount() - st);
		st = GetTickCount();

		GetLoadFileItems(tmpListFile, tmpLoadList);

		XLog::Trace("Use time2:%d\n", GetTickCount() - st);
		st = GetTickCount();

		m_updateList.Dir = tmpLoadList.Dir;

		for(LOADFILEGROUPLIST::iterator gItr = tmpLoadList.Groups.begin(); gItr != tmpLoadList.Groups.end(); ++gItr)
		{
			LOADFILEGROUPINFO group;
			group.Dir = gItr->Dir;
			group.nType = gItr->nType;
			group.sType = gItr->sType;

			for(LOADFILELIST::iterator fItr = gItr->Files.begin(); fItr != gItr->Files.end(); ++fItr)
			{
				int nwhere = EXISTS_TYPE_NONE;
				DWORD startPos = 0;
				DWORD size = 0;

				if(IsChanged2(*fItr, loadList, nwhere, startPos, size))
				{
					//加入下载列表
					if(EXISTS_TYPE_NONE == nwhere || (startPos != size))
					{
						LPLOADFILEITEM item = new LOADFILEITEM;
						item->Url = fItr->Url;
						item->Path = fItr->Path;
						item->GroupDir = gItr->Dir;
						item->GroupType = gItr->sType;
						item->ItemFile = fItr->File;
						item->ItemCode = fItr->Code;
						item->IsExit = EXISTS_TYPE_NONE == nwhere ? false : true;
						item->StartPos = startPos;
						item->Size = size;
						item->IsError = false;
						m_loadFiles.push_back(item);
					}

					//加入移动列表
					if(EXISTS_TYPE_DEST != nwhere)
					{
						LOADFILEINFO file;
						file.Url = fItr->Url;
						file.Path = fItr->Path;
						file.Code = fItr->Code;
						file.DstPath = fItr->DstPath;
						file.File = fItr->File;
						file.IsError = false;

						group.Files.push_back(file);

						m_totalMoveCnt ++;
					}

					//文件已在，但列表中没有，直接更新列表
					if(EXISTS_TYPE_DEST == nwhere)
						UpdateListFile(gItr->Dir.c_str(), gItr->sType.c_str(), fItr->File.c_str(), fItr->Code.c_str());

					CheckIsMe(fItr->File);
				}
			}

			if(group.Files.size())
				m_updateList.Groups.push_back(group);
		}

		ClearFileList(loadList);
		ClearFileList(tmpLoadList);

		XLog::Trace("Use time3:%d\n", GetTickCount() - st);
	}

	m_totalLoadCnt = m_loadFiles.size();
	m_stime = GetTickCount();
	m_totalUseTime = 0;
	m_totalUseTimeT = 0;

	m_pGaugeAll->SetRange(m_totalLoadCnt);
	m_pGaugeAll->SetValue(0);

}

//判断某个文件是否有更新
bool EQUpdaterMainWin::IsChanged2( LOADFILEINFO &loadInfo, LOADFILELISTINFO &loadList, int &nWhere, DWORD &startPos, DWORD &size )
{
	bool hasFind = false, isEqual = false;

	for(LOADFILEGROUPLIST::iterator grpIdr = loadList.Groups.begin(); grpIdr != loadList.Groups.end(); ++grpIdr)
	{
		LOADFILEMAPS::iterator fIdx = grpIdr->FMaps.find(loadInfo.Url);
		if(fIdx != grpIdr->FMaps.end())
		{
			if(fIdx->second.Code == loadInfo.Code)
				isEqual = true;

			hasFind = true;
			break;
		}
	}

	TEMPFILEDESC desc;
	const char *dstFile = loadInfo.DstPath.c_str(),
		*tmpFile = loadInfo.Path.c_str(),
		*code = loadInfo.Code.c_str();

	//存在在用户列表中
	if(hasFind)
	{
		//Code相同并且在目标目录中
		if(isEqual && XFuns::CheckFileExists(dstFile))
			return false;

		//检查文件是否在临时目录中
		if(false == GetFileDesc(tmpFile, &desc))
			return true;
		//检查临时目录中的文件Code
		if(0 != strcmp(desc.Code, code))
			return true;

		startPos = XFuns::GetFileSize(tmpFile);
		size = desc.Size;
		nWhere = EXISTS_TYPE_TEMP;

		return true;
	}

	//用户列表中不存在，直接检查目标目录中文件的存在性和Code
	if(XFuns::CheckFileExists(dstFile) && XFuns::CheckFileMd5(dstFile, code))
	{
		startPos = XFuns::GetFileSize(dstFile);
		size = startPos;
		nWhere = EXISTS_TYPE_DEST;

		return true;
	}

	//用户列表中不存在，文件也不存在目标目录中，或目标目录的文件code不匹配，检查临时目录文件
	if(false == XFuns::CheckFileExists(tmpFile))
		return true;
	if(false == GetFileDesc(tmpFile, &desc))
		return true;
	if(0 != strcmp(desc.Code, code))
		return true;

	startPos = XFuns::GetFileSize(tmpFile);
	size = desc.Size;
	nWhere = EXISTS_TYPE_TEMP;

	return true;
}

bool EQUpdaterMainWin::GetFileDesc(const char *file, LPTEMPFILEDESC desc)
{
	std::string fdesc = file;
	fdesc.append(DESC_SUFFIX);

	FILE *fp = fopen(fdesc.c_str(), "rb");
	if(NULL == fp)
		return false;

	fread(desc, sizeof(TEMPFILEDESC), 1, fp);
	fclose(fp);

	return true;
}

//加载文件配置
void EQUpdaterMainWin::LoadConfig()
{
	XIniFile iniFObj(CONFIG_FILE);
	if(false == iniFObj.ReadFile())
	{
		iniFObj.SetPath(CONFIG_FILE2);
		if (false == iniFObj.ReadFile())
			return;
	}

	m_serverAddr = iniFObj.GetValue(CONFIG_VARS, "SAddr");
	m_listFile = iniFObj.GetValue(CONFIG_VARS, "FList");
	m_runExe = iniFObj.GetValue(CONFIG_VARS, "Run");
	m_targetDir = iniFObj.GetValue(CONFIG_VARS, "RDir");
	m_runAfter = iniFObj.GetValueB(CONFIG_VARS, "RunAfter");

	wxString lf = wxString(XFuns::S2WS(m_listFile));
	lf.Replace(wxT("\\"), wxT("/"));
	int p = lf.find_last_of('/');
	if(-1 != p)
		lf.Remove(0, p + 1);
	m_listFName = lf.char_str();

#ifdef LIST_FILE_HAS_LOAD_IN_USERDIR
	m_tmpListFile.append("%HOMEDRIVE%%HOMEPATH%/");
#else
	m_tmpListFile.append(TEMP_LOAD_DIR);
#endif
	m_tmpListFile.append(m_listFName);

	XFuns::ExpandEnvVars(m_runExe);
	XFuns::ExpandEnvVars(m_targetDir);
	XFuns::ExpandEnvVars(m_tmpListFile);

}

//释放下载列表
void EQUpdaterMainWin::ClearFileList( LOADFILELISTINFO &fileList )
{
	for(LOADFILEGROUPLIST::iterator grpIdr = fileList.Groups.begin(); grpIdr != fileList.Groups.end(); ++grpIdr)
	{
		grpIdr->Files.clear();
		grpIdr->FMaps.clear();
	}

	fileList.Groups.clear();
}

//打开创建一个文件，若目录不存在会自动创建
FILE * EQUpdaterMainWin::OpenFile( const char *file, const char *mode )
{
	if(false == XFuns::CheckDir(file))
		return NULL;

	return fopen(file, mode);
}

//将下载到临时目录的文件移动到目标目录或包中
void EQUpdaterMainWin::MoveToTarget()
{
	DirFileManager dirFmObj;
	PackFileManager pckFmObj;

	for(LOADFILEGROUPLIST::iterator gItr = m_updateList.Groups.begin(); gItr != m_updateList.Groups.end(); ++gItr)
	{
		std::string dstDir;

		dstDir.append(m_targetDir);//目标存储根目录
		dstDir.append(m_updateList.Dir);//列表文件中的根目录

		if(nGROUP_TYPE_DIR == gItr->nType)//目录类型组中的目录
			dstDir.append(gItr->Dir);

		switch(gItr->nType)
		{
		case nGROUP_TYPE_DIR://目录目标类型的移动
			{
				for(LOADFILELIST::iterator fItr = gItr->Files.begin(); fItr != gItr->Files.end(); ++fItr)
				{
					if(false == XFuns::CheckFileExists(fItr->Path.c_str()))
						continue;
					if(fItr->IsError)
						continue;

					std::string dstPath = dstDir;
					std::string srcPath = fItr->Path;
					std::string befPath = TEMP_LOAD_DIR + m_updateList.Dir + gItr->Dir;
					srcPath.erase(0, befPath.size());
					int p = srcPath.find_last_of('/');
					if(-1 != p)
						dstPath.append(srcPath.substr(0, p + 1));
					if(dirFmObj.moveTo(dstPath.c_str(), fItr->Path.c_str()))
					{
						UpdateListFile(gItr->Dir.c_str(), gItr->sType.c_str(), fItr->File.c_str(), fItr->Code.c_str());
						XLog::Write("Move file [%s] ok!", fItr->File.c_str());
					}
				}
			}
			break;
		case nGROUP_TYPE_PACK://包目标类型的移动
			{
				std::vector<std::string> flist;

				for(LOADFILELIST::iterator fItr = gItr->Files.begin(); fItr != gItr->Files.end(); ++fItr)
				{
					flist.push_back(fItr->Path);
				}

				if(flist.size())
				{
					const char **sflist = (const char **)malloc(sizeof(const char *) * flist.size());

					for(int i = 0; i < flist.size(); i ++)
					{
						sflist[i] = flist[i].c_str();
					}
					pckFmObj.moveToBatch(dstDir.c_str(), sflist, flist.size());
					free(sflist);
				}

				flist.clear();
			}
			break;
		}
	}

}

void EQUpdaterMainWin::SetErrorFile( std::string &path )
{
	for(LOADFILEGROUPLIST::iterator gItr = m_updateList.Groups.begin(); gItr != m_updateList.Groups.end(); ++gItr)
	{
		for(LOADFILELIST::iterator fItr = gItr->Files.begin(); fItr != gItr->Files.end(); ++fItr)
		{
			if(fItr->Path == path)
			{
				fItr->IsError = true;
				return;
			}
		}
	}

}

//更新当前下载列表文件
void EQUpdaterMainWin::UpdateListFile(const char *groupDir, const char *groupType, const char *itemFile, const char *itemCode)
{
	bool isUpdated = false;
	TiXmlElement *eleList = m_curListDoc->RootElement();
	TiXmlElement *eleGroup = eleList->FirstChildElement();
	TiXmlElement *eleItem = NULL;

	while(eleGroup)
	{
		if(0 == strcmp(groupDir, eleGroup->Attribute(ATTRIBUTE_DIRECTORY)))
		{
			eleItem = eleGroup->FirstChildElement();

			while(eleItem)
			{
				if(0 == strcmp(itemFile, eleItem->Attribute(ATTRIBUTE_FILE)))
				{
					eleItem->SetAttribute(ATTRIBUTE_CODE, itemCode);
					isUpdated = true;
					break;
				}

				eleItem = eleItem->NextSiblingElement();
			}

			break;
		}

		eleGroup = eleGroup->NextSiblingElement();
	}

	if(false == isUpdated)
	{
		if(NULL == eleGroup)
		{
			eleGroup = new TiXmlElement(ELEMENT_GROUP);
			eleGroup->SetAttribute(ATTRIBUTE_DIRECTORY, groupDir);
			eleGroup->SetAttribute(ATTRIBUTE_TYPE, groupType);
			eleList->LinkEndChild(eleGroup);
		}

		eleItem = new TiXmlElement(ELEMENT_ITEM);
		eleItem->SetAttribute(ATTRIBUTE_FILE, itemFile);
		eleItem->SetAttribute(ATTRIBUTE_CODE, itemCode);
		eleGroup->LinkEndChild(eleItem);
	}

}

void EQUpdaterMainWin::OpenListFile()
{
	m_curListDoc = new TiXmlDocument();
	if(false == m_curListDoc->LoadFile(m_listFile.c_str()))
		m_curListDoc->Parse("");
	CheckDeclaration(*m_curListDoc);
	CheckRootElement(*m_curListDoc, m_updateList.Dir.c_str());

}

void EQUpdaterMainWin::CloseListFile()
{
	if(m_curListDoc)
	{
		m_curListDoc->SaveFile(m_listFile.c_str());
		delete m_curListDoc;
		m_curListDoc = NULL;
	}
}